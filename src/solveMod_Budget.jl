function solveProcess_Budget(fData::fixedData,uData::Dict{Any,Any},vmax,vmin,θDmax,θDmin,Γ = 1,ϵ = 1e-4)
  # create the initial master/sub problem
  # without any scenario and cuts yet
  totalD = sum(abs(fData.Pd[j]) + abs(fData.Qd[j]) for j in fData.IDList);
  mp = createM_Budget(fData,uData);
  sp,spobjo = createS_Budget(fData,uData,vmax,vmin,θDmax,θDmin,Γ);
  # number of cuts so far and the set of cut coefficients
  nC = 0;
  C = [];

  solve(mp);
  lbCost = getobjectivevalue(mp);

  # record the value of decision variable sp and sq
  sphat = Dict();
  sqhat = Dict();
  spobj = copy(spobjo);
  for i in fData.genIDList
    sphat[i] = getvalue(mp[:sp][i]);
    sqhat[i] = getvalue(mp[:sq][i]);
    # update the subproblem objective function with the current master solutions
    spobj -= (sphat[i]*sp[:λpi][fData.Loc[i]] + sqhat[i]*sp[:λqi][fData.Loc[i]]);
  end
  @objective(sp,Max,spobj);
#  sp.solver = GurobiSolver(MIPGap = 0.04,MIQCPMethod = 0);
  solve(sp);

  bestyp = Dict();
  bestyq = Dict();
  for i in fData.IDList
    bestyp[i] = round(getvalue(sp[:ypplus][i])) - round(getvalue(sp[:ypminus][i]));
    bestyq[i] = round(getvalue(sp[:yqplus][i])) - round(getvalue(sp[:yqminus][i]));
  end
  # solve for the λ using the yp/yq generated by the Benders decomposition
  spH,spHobjo = createSH(fData,uData,bestyp,bestyq,vmax,vmin,θDmax,θDmin);
  for i in fData.genIDList
    # update the subproblem objective function with the current master solutions
    spHobjo -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
  end
  @objective(spH,Max,spHobjo);
  solve(spH);
  # obtain the objective value to test whether the current solution is feasible
  vioSP = getobjectivevalue(spH);
  while vioSP > ϵ*totalD
    # obtain the dual variables to form a cut
    λpr = Dict();
    λqr = Dict();
    for i in fData.genIDList
      λpr[i] = getvalue(spH[:λpi][fData.Loc[i]]);
      λqr[i] = getvalue(spH[:λqi][fData.Loc[i]]);
    end
    # append the cut to the master program
    nC += 1;
    println("------------------------------------------------------------------------------------------------------")
    println("Iteration No. = $(nC), violation = $(vioSP)");
    println("------------------------------------------------------------------------------------------------------")
    cutTemp = @constraint(mp,vioSP - sum(λpr[i]*(mp[:sp][i] - sphat[i]) for i in fData.genIDList) -
      sum(λqr[i]*(mp[:sq][i]-sqhat[i]) for i in fData.genIDList) <= 0);
    push!(C,cutTemp);

    # solve the master program, repeat the iteration
    solve(mp);
    lbCost = getobjectivevalue(mp);
    # record the value of decision variable sp and sq
    sphat = Dict();
    sqhat = Dict();
    spobj = copy(spobjo);
    for i in fData.genIDList
      sphat[i] = getvalue(mp[:sp][i]);
      sqhat[i] = getvalue(mp[:sq][i]);
      # update the subproblem objective function with the current master solutions
      spobj -= (sphat[i]*sp[:λpi][fData.Loc[i]] + sqhat[i]*sp[:λqi][fData.Loc[i]]);
    end
    @objective(sp,Max,spobj);
    solve(sp);

    bestyp = Dict();
    bestyq = Dict();
    for i in fData.IDList
      bestyp[i] = round(getvalue(sp[:ypplus][i])) - round(getvalue(sp[:ypminus][i]));
      bestyq[i] = round(getvalue(sp[:yqplus][i])) - round(getvalue(sp[:yqminus][i]));
    end
    # solve for the λ using the yp/yq generated by the Benders decomposition
    spH,spHobjo = createSH_Budget(fData,uData,bestyp,bestyq,vmax,vmin,θDmax,θDmin);
    spHobj = spHobjo;
    for i in fData.genIDList
      # update the subproblem objective function with the current master solutions
      spHobj -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
    end
    @objective(spH,Max,spHobj);
    solve(spH);
    # obtain the objective value to test whether the current solution is feasible
    vioSP = getobjectivevalue(spH);
  end

  # sphat/sqhat is the final solution
  return sphat,sqhat,nC,C,vioSP,lbCost;
end
