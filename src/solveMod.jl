# this is the function to execute the solving process
# the output will be the optimal solution
function solveProcess(fData::fixedData,uData::Dict{Any,Any},vmax,vmin,θDmax,θDmin,ϵ = 1e-4)
  # create the initial master/sub problem
  # without any scenario and cuts yet
  mp = createM(fData,uData);
  sp,spobjo = createS(fData,uData,vmax,vmin,θDmax,θDmin);
  # number of cuts so far and the set of cut coefficients
  nC = 0;
  C = [];

  solve(mp);
  lbCost = getobjectivevalue(mp);

  # record the value of decision variable sp and sq
  sphat = Dict();
  sqhat = Dict();
  spobj = copy(spobjo);
  for i in fData.genIDList
    sphat[i] = getvalue(mp[:sp][i]);
    sqhat[i] = getvalue(mp[:sq][i]);
    # update the subproblem objective function with the current master solutions
    spobj -= (sphat[i]*sp[:λpi][fData.Loc[i]] + sqhat[i]*sp[:λqi][fData.Loc[i]]);
  end
  @objective(sp,Max,spobj);
#  sp.solver = GurobiSolver(MIPGap = 0.04,MIQCPMethod = 0);
  solve(sp);

  bestyp = Dict();
  bestyq = Dict();
  for i in fData.IDList
    bestyp[i] = round(getvalue(sp[:yp][i]));
    bestyq[i] = round(getvalue(sp[:yq][i]));
  end
  # solve for the λ using the yp/yq generated by the Benders decomposition
  spH,spHobjo = createSH(fData,uData,bestyp,bestyq,vmax,vmin,θDmax,θDmin);
  for i in fData.genIDList
    # update the subproblem objective function with the current master solutions
    spHobjo -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
  end
  @objective(spH,Max,spHobjo);
  solve(spH);
  # obtain the objective value to test whether the current solution is feasible
  vioSP = getobjectivevalue(spH);
  while vioSP > ϵ
    # obtain the dual variables to form a cut
    λpr = Dict();
    λqr = Dict();
    for i in fData.genIDList
      λpr[i] = getvalue(spH[:λpi][fData.Loc[i]]);
      λqr[i] = getvalue(spH[:λqi][fData.Loc[i]]);
    end
    # append the cut to the master program
    nC += 1;
    println("------------------------------------------------------------------------------------------------------")
    println("Iteration No. = $(nC), violation = $(vioSP)");
    println("------------------------------------------------------------------------------------------------------")
    cutTemp = @constraint(mp,vioSP - sum(λpr[i]*(mp[:sp][i] - sphat[i]) for i in fData.genIDList) -
      sum(λqr[i]*(mp[:sq][i]-sqhat[i]) for i in fData.genIDList) <= 0);
    push!(C,cutTemp);

    # solve the master program, repeat the iteration
    solve(mp);
    lbCost = getobjectivevalue(mp);
    # record the value of decision variable sp and sq
    sphat = Dict();
    sqhat = Dict();
    spobj = copy(spobjo);
    for i in fData.genIDList
      sphat[i] = getvalue(mp[:sp][i]);
      sqhat[i] = getvalue(mp[:sq][i]);
      # update the subproblem objective function with the current master solutions
      spobj -= (sphat[i]*sp[:λpi][fData.Loc[i]] + sqhat[i]*sp[:λqi][fData.Loc[i]]);
    end
    @objective(sp,Max,spobj);
    solve(sp);

    bestyp = Dict();
    bestyq = Dict();
    for i in fData.IDList
      bestyp[i] = round(getvalue(sp[:yp][i]));
      bestyq[i] = round(getvalue(sp[:yq][i]));
    end
    # solve for the λ using the yp/yq generated by the Benders decomposition
    spH,spHobjo = createSH(fData,uData,bestyp,bestyq,vmax,vmin,θDmax,θDmin);
    spHobj = spHobjo;
    for i in fData.genIDList
      # update the subproblem objective function with the current master solutions
      spHobj -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
    end
    @objective(spH,Max,spHobj);
    solve(spH);
    # obtain the objective value to test whether the current solution is feasible
    vioSP = getobjectivevalue(spH);
  end

  ypr = Dict();
  yqr = Dict();
  for i in fData.IDList
    ypr[i] = getvalue(sp[:yp][i]);
  end
  for i in fData.IDList
    yqr[i] = getvalue(sp[:yq][i]);
  end

  # sphat/sqhat is the final solution
  return sphat,sqhat,nC,C,vioSP,ypr,yqr,lbCost;
end

function solveProcessC(fData::fixedData,uData::Dict{Any,Any},ϵ = 1e-4)
  # create the initial master/sub problem
  # without any scenario and cuts yet
  mp = createM(fData,uData);
  # number of cuts so far and the set of cut coefficients
  nC = 0;
  C = [];

  solve(mp);
  lbCost = getobjectivevalue(mp);

  # record the value of decision variable sp and sq
  sphat = Dict();
  sqhat = Dict();
  for i in fData.genIDList
    sphat[i] = getvalue(mp[:sp][i]);
    sqhat[i] = getvalue(mp[:sq][i]);
  end
  #sp,vioSP,bestyp,bestyq = solveCut(fData,uData,sphat,sqhat);
  sp,vioSP,bestyp,bestyq = solveCut2(fData,uData,sphat,sqhat);
  #sp,vioSP,bestyp,bestyq = solveCut3(fData,uData,sphat,sqhat);

  bestyp = Dict();
  bestyq = Dict();
  for i in fData.IDList
    bestyp[i] = round(getvalue(sp[:yp][i]));
    bestyq[i] = round(getvalue(sp[:yq][i]));
  end

  # solve for the λ using the yp/yq generated by the Benders decomposition
  spH,spHobjo = createSH(fData,uData,bestyp,bestyq);
  for i in fData.genIDList
    # update the subproblem objective function with the current master solutions
    spHobjo -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
  end
  @objective(spH,Max,spHobjo);
  solve(spH);
  # obtain the objective value to test whether the current solution is feasible
  vioSP = getobjectivevalue(spH);
  while vioSP > ϵ
    # obtain the dual variables to form a cut
    λpr = Dict();
    λqr = Dict();
    for i in fData.genIDList
      λpr[i] = getvalue(spH[:λpi][fData.Loc[i]]);
      λqr[i] = getvalue(spH[:λqi][fData.Loc[i]]);
    end
    # append the cut to the master program
    nC += 1;
    println("------------------------------------------------------------------------------------------------------")
    print("Iteration No. = ");
    println(nC);
    println("------------------------------------------------------------------------------------------------------")
    cutTemp = @constraint(mp,vioSP - sum(λpr[i]*(mp[:sp][i] - sphat[i]) for i in fData.genIDList) -
      sum(λqr[i]*(mp[:sq][i]-sqhat[i]) for i in fData.genIDList) <= 0);
    push!(C,cutTemp);

    # solve the master program, repeat the iteration
    solve(mp);
    lbCost = getobjectivevalue(mp);
    # record the value of decision variable sp and sq
    sphat = Dict();
    sqhat = Dict();
    for i in fData.genIDList
      sphat[i] = getvalue(mp[:sp][i]);
      sqhat[i] = getvalue(mp[:sq][i]);
    end
    # sp,vioSP = solveCut(fData,uData,sphat,sqhat);
    sp,vioSP = solveCut2(fData,uData,sphat,sqhat);
    # sp,vioSP = solveCut3(fData,uData,sphat,sqhat);

    bestyp = Dict();
    bestyq = Dict();
    for i in fData.IDList
      bestyp[i] = round(getvalue(sp[:yp][i]));
      bestyq[i] = round(getvalue(sp[:yq][i]));
    end

    # solve for the λ using the yp/yq generated by the Benders decomposition
    spH,spHobjo = createSH(fData,uData,bestyp,bestyq);
    spHobj = spHobjo;
    for i in fData.genIDList
      # update the subproblem objective function with the current master solutions
      spHobj -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
    end
    @objective(spH,Max,spHobj);
    solve(spH);
    # obtain the objective value to test whether the current solution is feasible
    vioSP = getobjectivevalue(spH);
  end

  ypr = Dict();
  yqr = Dict();
  for i in fData.IDList
    ypr[i] = getvalue(sp[:yp][i]);
  end
  for i in fData.IDList
    yqr[i] = getvalue(sp[:yq][i]);
  end

  # sphat/sqhat is the final solution
  return sphat,sqhat,nC,C,vioSP,ypr,yqr,lbCost;
end

function solveProcessCCplex(fData::fixedData,uData::Dict{Any,Any},ϵ = 1e-4)
  # create the initial master/sub problem
  # without any scenario and cuts yet
  mp = createM(fData,uData);
  # number of cuts so far and the set of cut coefficients
  nC = 0;
  C = [];

  solve(mp);
  lbCost = getobjectivevalue(mp);

  # record the value of decision variable sp and sq
  sphat = Dict();
  sqhat = Dict();
  for i in fData.genIDList
    sphat[i] = getvalue(mp[:sp][i]);
    sqhat[i] = getvalue(mp[:sq][i]);
  end
  #sp,vioSP = solveCutCplex(fData,uData,sphat,sqhat);
  sp,vioSP = solveCut2Cplex(fData,uData,sphat,sqhat);
  #sp,vioSP = solveCut3Cplex(fData,uData,sphat,sqhat);

  bestyp = Dict();
  bestyq = Dict();
  for i in fData.IDList
    bestyp[i] = round(getvalue(sp[:yp][i]));
    bestyq[i] = round(getvalue(sp[:yq][i]));
  end

  # solve for the λ using the yp/yq generated by the Benders decomposition
  spH,spHobjo = createSH(fData,uData,bestyp,bestyq);
  for i in fData.genIDList
    # update the subproblem objective function with the current master solutions
    spHobjo -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
  end
  @objective(spH,Max,spHobjo);
  solve(spH);
  # obtain the objective value to test whether the current solution is feasible
  vioSP = getobjectivevalue(spH);
  while vioSP > ϵ
    # obtain the dual variables to form a cut
    λpr = Dict();
    λqr = Dict();
    for i in fData.genIDList
      λpr[i] = getvalue(spH[:λpi][fData.Loc[i]]);
      λqr[i] = getvalue(spH[:λqi][fData.Loc[i]]);
    end
    # append the cut to the master program
    nC += 1;
    println("------------------------------------------------------------------------------------------------------")
    print("Iteration No. = ");
    println(nC);
    println("------------------------------------------------------------------------------------------------------")
    cutTemp = @constraint(mp,vioSP - sum(λpr[i]*(mp[:sp][i] - sphat[i]) for i in fData.genIDList) -
      sum(λqr[i]*(mp[:sq][i]-sqhat[i]) for i in fData.genIDList) <= 0);
    push!(C,cutTemp);

    # solve the master program, repeat the iteration
    solve(mp);
    lbCost = getobjectivevalue(mp);
    # record the value of decision variable sp and sq
    sphat = Dict();
    sqhat = Dict();
    for i in fData.genIDList
      sphat[i] = getvalue(mp[:sp][i]);
      sqhat[i] = getvalue(mp[:sq][i]);
    end
    #sp,vioSP = solveCutCplex(fData,uData,sphat,sqhat);
    sp,vioSP = solveCut2Cplex(fData,uData,sphat,sqhat);
    # sp,vioSP = solveCut3Cplex(fData,uData,sphat,sqhat);

    bestyp = Dict();
    bestyq = Dict();
    for i in fData.IDList
      bestyp[i] = round(getvalue(sp[:yp][i]));
      bestyq[i] = round(getvalue(sp[:yq][i]));
    end

    # solve for the λ using the yp/yq generated by the Benders decomposition
    spH,spHobjo = createSH(fData,uData,bestyp,bestyq);
    spHobj = spHobjo;
    for i in fData.genIDList
      # update the subproblem objective function with the current master solutions
      spHobj -= (sphat[i]*spH[:λpi][fData.Loc[i]] + sqhat[i]*spH[:λqi][fData.Loc[i]]);
    end
    @objective(spH,Max,spHobj);
    solve(spH);
    # obtain the objective value to test whether the current solution is feasible
    vioSP = getobjectivevalue(spH);
  end

  ypr = Dict();
  yqr = Dict();
  for i in fData.IDList
    ypr[i] = getvalue(sp[:yp][i]);
  end
  for i in fData.IDList
    yqr[i] = getvalue(sp[:yq][i]);
  end

  # sphat/sqhat is the final solution
  return sphat,sqhat,nC,C,vioSP,ypr,yqr,lbCost;
end
